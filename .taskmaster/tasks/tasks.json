{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository",
      "description": "Initialize the GitHub repository for the markdown viewer project with Tauri and Rust setup according to TECH_ARCHITECTURE.md and IMPLEMENTATION_GUIDES.md specifications.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new GitHub repository named 'markdown-viewer'. Initialize it with a README.md, LICENSE (MIT recommended), and a .gitignore file for Rust and Node.js. Set up the basic Tauri project structure with `npm create tauri-app` and configure the initial `Cargo.toml` and `package.json` files as documented in TECH_ARCHITECTURE.md build configuration section.",
      "testStrategy": "1. Verify repository creation and initial files match IMPLEMENTATION_GUIDES.md requirements\n2. Confirm Tauri project initialization by checking all configuration files\n3. Run `npm run tauri dev` to ensure the project compiles and launches a blank window within 500ms\n4. Verify all documented dependencies in TECH_ARCHITECTURE.md are correctly configured",
      "subtasks": [
        {
          "id": 1,
          "title": "Creating the GitHub repository",
          "description": "Create a new repository on GitHub with the desired name and visibility settings as specified in IMPLEMENTATION_GUIDES.md.",
          "dependencies": [],
          "details": "Navigate to GitHub, click 'New repository', fill in the repository name, choose public or private visibility according to project requirements, and create the repository.",
          "status": "cancelled"
        },
        {
          "id": 2,
          "title": "Initializing with README, LICENSE, and .gitignore",
          "description": "Initialize the repository with essential files including README, LICENSE, and .gitignore as documented in IMPLEMENTATION_GUIDES.md.",
          "dependencies": [
            1
          ],
          "details": "After creating the repository, add a README.md file following project templates, choose MIT LICENSE file, and create a .gitignore file to exclude unnecessary files from version control with patterns from TECH_ARCHITECTURE.md.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Setting up Tauri project structure",
          "description": "Set up the Tauri project structure within the repository according to TECH_ARCHITECTURE.md build configuration.",
          "dependencies": [
            2
          ],
          "details": "Follow the Tauri documentation and TECH_ARCHITECTURE.md to initialize the project structure, including the necessary configuration files and directories for a Tauri application with all required dependencies.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Verifying the initial build",
          "description": "Verify that the initial build of the Tauri project meets performance and configuration requirements.",
          "dependencies": [
            3
          ],
          "details": "1. Run `npm run tauri dev` and verify build completes in under 500ms\n2. Confirm all dependencies from TECH_ARCHITECTURE.md are properly configured\n3. Validate application launches a blank window without errors\n<info added on 2025-06-11T09:58:29.899Z>\nFixed duplicate identifier in Tauri configuration. Build verification pending Rust toolchain installation on Windows. Configuration files and project structure validated as correct.\n</info added on 2025-06-11T09:58:29.899Z>\n<info added on 2025-06-11T10:12:02.540Z>\nBuild verification completed successfully with all configuration issues resolved. Fixed Tauri config (removed duplicate identifier) and corrected Cargo.toml dependencies (removed invalid features). Established working Windows PowerShell + Rust toolchain workflow. Build completed in ~65 seconds with application launching correctly. All project dependencies validated and working as expected.\n</info added on 2025-06-11T10:12:02.540Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Basic Markdown Rendering",
      "description": "Set up the core functionality to render CommonMark standard markdown files following implementation guidelines.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Use `pulldown-cmark` (v0.9.2) in the Rust backend to parse markdown content into HTML as specified in IMPLEMENTATION_GUIDES.md section 1. Create a Tauri command following the patterns documented in section 1.2 to read and parse markdown files. The frontend will display the parsed HTML in a simple viewer layout using the integration examples from section 1.3.",
      "testStrategy": "Test with various markdown files to ensure correct rendering of headers, paragraphs, lists, and inline formatting. Validate file reading and parsing errors are handled gracefully. Refer to test cases in IMPLEMENTATION_GUIDES.md section 1.4.",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrating pulldown-cmark",
          "description": "Add the pulldown-cmark library to the project and set up basic markdown parsing functionality following section 1.1 of IMPLEMENTATION_GUIDES.md.",
          "dependencies": [],
          "details": "Include pulldown-cmark as a dependency in Cargo.toml and write a simple function to parse markdown text as shown in the implementation guide examples.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Creating Tauri command for file reading and parsing",
          "description": "Implement a Tauri command to read markdown files and parse them using pulldown-cmark following patterns in section 1.2.",
          "dependencies": [
            1
          ],
          "details": "Create a Rust function exposed as a Tauri command that reads a file and returns parsed markdown content, using the code examples from IMPLEMENTATION_GUIDES.md section 1.2.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Setting up the frontend viewer layout",
          "description": "Design and implement the frontend layout to display the parsed markdown content using examples from section 1.3.",
          "dependencies": [
            2
          ],
          "details": "Create a React/Vue/Svelte component that renders the markdown content received from the Tauri command following the integration patterns in IMPLEMENTATION_GUIDES.md section 1.3.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Implement file watching for auto-reload",
          "description": "Add file system watching to automatically reload content when the markdown file changes",
          "details": "Reference implementation patterns in IMPLEMENTATION_GUIDES.md section 1.5 for file watching setup.",
          "status": "done",
          "dependencies": [
            2
          ],
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "Add Syntax Highlighting for Code Blocks",
      "description": "Integrate syntax highlighting for code blocks in markdown files",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Use `syntect` (v4.6.0) in the Rust backend for syntax highlighting following Tauri command patterns for HTML generation. Configure it to support 20+ common programming languages. Pass highlighted HTML to the frontend for rendering while maintaining CommonMark spec compliance.",
      "testStrategy": "Test with code samples in multiple languages to verify proper highlighting. Verify no performance degradation with large code blocks.",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrating syntect for syntax highlighting",
          "description": "Integrate the syntect library into the project to enable syntax highlighting functionality.",
          "dependencies": [],
          "details": "This involves adding syntect as a dependency, setting up the necessary build configurations, and ensuring the library is correctly initialized within the project.\n<info added on 2025-06-11T13:12:29.759Z>\nAdded syntect dependency and integrated basic syntax highlighting functionality into the parse_markdown function. The implementation uses post-processing to find code blocks and apply syntect highlighting. Successfully compiles with no errors.\n</info added on 2025-06-11T13:12:29.759Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Configuring language support and passing HTML to frontend",
          "description": "Configure syntect to support the desired programming languages and pass the generated HTML to the frontend for display.",
          "dependencies": [
            1
          ],
          "details": "This step includes setting up language definitions, configuring syntax highlighting options following Tauri command patterns, and ensuring the HTML output is correctly formatted and passed to the frontend components while maintaining CommonMark compliance.\n<info added on 2025-06-11T13:19:24.911Z>\nConfigure and test language support definitions for common programming languages. Validate pulldown-cmark HTML output format matches expected syntax highlighting structure. Refine regex patterns for accurate code block detection in markdown content, ensuring proper language identification and highlighting scope handling. Document any required adjustments to the HTML output formatting for frontend integration.\n</info added on 2025-06-11T13:19:24.911Z>\n<info added on 2025-06-11T13:21:22.034Z>\nImplemented enhanced syntax highlighting with robust language detection and theme selection capabilities. Added comprehensive support for language aliases to improve recognition accuracy. Updated regex patterns to precisely match pulldown-cmark HTML output format. Integrated debugging output system to monitor and log language recognition results and syntax highlighting performance, including success/failure cases for troubleshooting.\n</info added on 2025-06-11T13:21:22.034Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement Image and Table Rendering",
      "description": "Enable rendering of images (local and remote) and tables in markdown files",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Extend pulldown-cmark parser options to handle image tags and table syntax. Implement CSS styling following GitHub theme for tables. Ensure local images are resolved relative to the markdown file and work in exported formats.",
      "testStrategy": "Test with various image formats (local and remote) and table structures. Verify responsive behavior and proper rendering in exported HTML/PDF.",
      "subtasks": [
        {
          "id": 1,
          "title": "Extending the parser for images and tables",
          "description": "Modify the existing parser to handle image and table elements within the content.",
          "dependencies": [],
          "details": "Extend pulldown-cmark parser options to correctly identify and process image and table tags, extracting relevant attributes and content.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implementing CSS styling for tables",
          "description": "Add CSS styles following GitHub theme for tables.",
          "dependencies": [
            1
          ],
          "details": "Define and apply GitHub-style CSS rules to tables for responsive design, including borders, spacing, and alignment.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement export format support",
          "description": "Ensure images and tables render correctly in exported HTML/PDF formats.",
          "dependencies": [
            1,
            2
          ],
          "details": "Test and adjust rendering logic to maintain image and table formatting in exported documents.",
          "status": "done"
        }
      ]
    },
    {
      "id": 5,
      "title": "Add Math Equation Support",
      "description": "Integrate KaTeX for rendering math equations in markdown files.",
      "details": "Include KaTeX (v0.16.4) in the frontend to render math equations. Configure it to handle inline and block equations.",
      "testStrategy": "Test with markdown files containing math equations to ensure correct rendering and alignment.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "deferred",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrating KaTeX in the frontend",
          "description": "Add KaTeX library to the frontend project and ensure it is properly loaded and initialized.",
          "dependencies": [],
          "details": "Include KaTeX CSS and JS files in the project, either via CDN or local installation. Verify that the library is loaded correctly by testing basic rendering.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Configuring inline and block equation handling",
          "description": "Set up the frontend to handle both inline and block equations using KaTeX.",
          "dependencies": [
            1
          ],
          "details": "Implement logic to detect and render inline equations (e.g., single dollar signs) and block equations (e.g., double dollar signs or specific tags). Test with various equation formats to ensure proper rendering.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Mermaid Diagram Support",
      "description": "Add support for rendering Mermaid diagrams in markdown files.",
      "details": "Include Mermaid.js (v9.3.0) in the frontend to render diagrams. Configure it to handle flowchart, sequence, and other diagram types.",
      "testStrategy": "Test with markdown files containing Mermaid diagrams to ensure proper rendering and interactivity.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrating Mermaid.js",
          "description": "Add Mermaid.js library to the project and ensure it is properly loaded and initialized.",
          "dependencies": [],
          "details": "Include the Mermaid.js script in the project, either via CDN or npm package, and verify it loads without errors.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Configuring diagram types and interactivity",
          "description": "Set up and test different diagram types supported by Mermaid.js and configure interactivity options.",
          "dependencies": [
            1
          ],
          "details": "Explore and implement various diagram types (e.g., flowcharts, sequence diagrams) and enable interactive features like zoom or click events.",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "Create Table of Contents Sidebar",
      "description": "Generate and display an auto-updating table of contents sidebar following UI_UX_GUIDE.md specifications.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Parse markdown headers to generate a TOC. Implement a collapsible sidebar in the frontend that updates as the user scrolls. Refer to UI_UX_GUIDE.md for layout structure, component implementation examples, and scroll sync functionality.",
      "testStrategy": "Test with markdown files of varying lengths to ensure TOC generation and navigation work correctly. Verify implementation matches UI_UX_GUIDE.md specifications.",
      "subtasks": [
        {
          "id": 1,
          "title": "Parsing headers for TOC",
          "description": "Extract headers from the document to generate a table of contents (TOC).",
          "dependencies": [],
          "details": "Identify and parse all header tags (e.g., h1, h2, h3) in the document to create a structured TOC.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implementing the sidebar UI",
          "description": "Design and implement the sidebar that will display the TOC following UI_UX_GUIDE.md.",
          "dependencies": [
            1
          ],
          "details": "Create a responsive sidebar UI that lists the parsed headers in a hierarchical manner. Use component implementation examples from UI_UX_GUIDE.md.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Adding scroll-based updates",
          "description": "Update the sidebar TOC based on the user's scroll position using UI_UX_GUIDE.md specifications.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement functionality to highlight the current section in the TOC as the user scrolls through the document, following scroll sync patterns from UI_UX_GUIDE.md.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "Enable File Association and Drag & Drop",
      "description": "Allow users to open markdown files via double-click or drag & drop.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Configure Tauri to handle file associations for `.md` files following IMPLEMENTATION_GUIDES.md section 2. Implement drag & drop functionality in the frontend to open files.",
      "testStrategy": "Test file association on Windows, macOS, and Linux following platform-specific testing procedures in IMPLEMENTATION_GUIDES.md. Verify drag & drop functionality works as expected.",
      "subtasks": [
        {
          "id": 1,
          "title": "Configuring Tauri for file associations",
          "description": "Set up Tauri to handle specific file types by modifying the Tauri configuration file following IMPLEMENTATION_GUIDES.md section 2.",
          "dependencies": [],
          "details": "Update the `tauri.conf.json` file using the examples in IMPLEMENTATION_GUIDES.md section 2, including file extensions and protocols the app should handle. Pay special attention to platform-specific notes in the guide.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implementing drag & drop in the frontend",
          "description": "Add drag and drop functionality to the frontend to allow users to interact with files.",
          "dependencies": [
            1
          ],
          "details": "Use JavaScript event listeners to handle drag and drop events, validate file types, and process the dropped files.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Testing across platforms",
          "description": "Test the file association and drag & drop features on different operating systems following IMPLEMENTATION_GUIDES.md procedures.",
          "dependencies": [
            1,
            2
          ],
          "details": "Run tests on Windows, macOS, and Linux according to the testing procedures in IMPLEMENTATION_GUIDES.md section 2 to ensure the features work as expected on all supported platforms.",
          "status": "done"
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Recent Files List",
      "description": "Maintain and display a list of recently opened markdown files",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "low",
      "details": "Use browser localStorage for persistence, implement dropdown/sidebar UI component. Reference: TECH_ARCHITECTURE.md (file handling architecture), UI_UX_GUIDE.md (navigation patterns)",
      "testStrategy": "Test file persistence, UI interaction, and cleanup of invalid entries",
      "subtasks": [
        {
          "id": 1,
          "title": "Storing recent files in local storage",
          "description": "Implement functionality to save recently accessed files in the browser's local storage.",
          "dependencies": [],
          "details": "Ensure the files are stored with relevant metadata (e.g., name, path, timestamp) and limit the number of stored files to a reasonable amount (e.g., last 10 files). Implement automatic cleanup of invalid/deleted files.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Displaying recent files in a dropdown or sidebar",
          "description": "Create a UI component (dropdown or sidebar) to display the list of recently accessed files stored in local storage.",
          "dependencies": [
            1
          ],
          "details": "The component should fetch and display the files from local storage, allow users to click on a file to open it, and update dynamically when new files are added. Follow UI patterns from UI_UX_GUIDE.md.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement cleanup of invalid entries",
          "description": "Add functionality to automatically remove invalid or deleted files from the recent files list.",
          "dependencies": [
            1
          ],
          "details": "When loading the recent files list, verify each file still exists and remove any invalid entries from local storage.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "Add Zoom In/Out Functionality",
      "description": "Allow users to zoom in and out of the markdown content (50%-200% range)",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "low",
      "details": "CSS transform scaling with keyboard shortcuts (Ctrl +/-), maintain performance during zoom. Documentation references: UI_UX_GUIDE.md (interaction patterns), TECH_ARCHITECTURE.md (performance requirements).",
      "testStrategy": "Test zoom functionality with various content types, verify performance with large files.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implementing zoom controls",
          "description": "Add UI controls to allow users to zoom in and out of the content.",
          "dependencies": [],
          "details": "Create zoom in and zoom out buttons or a slider. Ensure the controls are intuitive and responsive. Implement keyboard shortcuts (Ctrl +/-).",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Adjusting font size and spacing dynamically",
          "description": "Modify the font size and spacing of text elements based on user preferences or zoom level.",
          "dependencies": [
            1
          ],
          "details": "Use CSS transform scaling to adjust content. Ensure readability is maintained at all zoom levels and performance requirements are met.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Persist zoom level per file",
          "description": "Maintain zoom level for each file during the session.",
          "dependencies": [
            1,
            2
          ],
          "details": "Store and retrieve zoom level from session storage for each file.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Performance optimization",
          "description": "Ensure no performance degradation during zoom operations.",
          "dependencies": [
            2
          ],
          "details": "Test and optimize zoom operations, especially with large files.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement Find in Page",
      "description": "Add search feature to find text within the markdown file (Ctrl+F)",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Custom search with highlighting, keyboard navigation between matches, browser-like UX. Reference: UI_UX_GUIDE.md (interaction patterns, keyboard navigation), TECH_ARCHITECTURE.md (performance requirements)",
      "testStrategy": "Test search accuracy, performance with large files (up to 10MB), keyboard navigation UX. Ensure search performance <100ms.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implementing custom search functionality",
          "description": "Develop the backend and frontend logic to enable custom search within the application.",
          "dependencies": [],
          "details": "Create APIs for search queries and integrate with frontend. Implement case-sensitive and whole word search options. Ensure performance meets <100ms requirement.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Highlighting matches and navigation",
          "description": "Enhance the UI to highlight search matches and provide keyboard navigation between them.",
          "dependencies": [
            1
          ],
          "details": "Implement UI components that visually highlight search results. Add keyboard navigation controls (Enter/Shift+Enter) to move between matches. Ensure search dialog opens with Ctrl+F.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement search dialog and keyboard shortcuts",
          "description": "Add search dialog that opens with Ctrl+F and supports keyboard navigation",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement browser-like search dialog with keyboard shortcuts for opening and navigation. Follow UI_UX_GUIDE.md patterns.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 12,
      "title": "Add Print to PDF and Export as HTML",
      "description": "Enable users to print markdown content as PDF, save it as HTML, or copy selected text with formatting preserved.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "low",
      "details": "Use the browser's print functionality for PDF export. For HTML export, save the rendered HTML as a self-contained file. Add functionality to copy selected text with formatting.",
      "testStrategy": "Test printing, exporting, and formatted copy with various markdown files to ensure formatting is preserved in all cases.",
      "subtasks": [
        {
          "id": 1,
          "title": "Using browser print for PDF",
          "description": "Leverage the browser's built-in print functionality to generate a PDF from the current webpage.",
          "dependencies": [],
          "details": "This involves calling the window.print() method and configuring the print dialog to save as PDF.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Saving rendered HTML as a file",
          "description": "Save the fully rendered HTML of the current webpage as a file on the local system.",
          "dependencies": [],
          "details": "This involves capturing the current DOM, converting it to a string, and using the File API or a download link to save it.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Add copy selection as formatted text",
          "description": "Implement functionality to copy selected text with formatting preserved.",
          "dependencies": [],
          "details": "This involves capturing the selected content with its HTML structure and using the Clipboard API to copy it with formatting.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Dark Mode and Themes",
      "description": "Add support for GitHub-style default theme (dark mode and additional themes to be implemented in Phase 2).",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "low",
      "details": "Create GitHub-style CSS theme as the default. Theme switcher implementation will be deferred to Phase 2.",
      "testStrategy": "Verify GitHub theme renders correctly with all markdown elements.",
      "subtasks": [
        {
          "id": 1,
          "title": "Creating GitHub theme",
          "description": "Design and implement GitHub-style CSS theme for the application.",
          "dependencies": [],
          "details": "Define color scheme, typography, and styling elements matching GitHub's style. Ensure theme covers all UI components.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Remove theme switcher (defer to Phase 2)",
          "description": "Theme switcher implementation will be handled in Phase 2 when additional themes are added.",
          "dependencies": [],
          "details": "No theme switcher needed for MVP. This will be implemented when dark mode and other themes are added.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Testing theme rendering",
          "description": "Verify that GitHub theme renders correctly across different components and browsers.",
          "dependencies": [
            1
          ],
          "details": "Test GitHub theme to ensure consistency and correctness. Check for any rendering issues or inconsistencies in various browsers and devices.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "Build and Package Executables",
      "description": "Create distributable executables for Windows, macOS, and Linux.",
      "status": "pending",
      "dependencies": [
        17,
        19
      ],
      "priority": "high",
      "details": "Use `npm run tauri build` to generate executables. Ensure the build size meets targets (Windows: <25MB, macOS: <20MB, Linux: <30MB).",
      "testStrategy": "Test executables on each platform to ensure they launch and function correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Building for Windows",
          "description": "Compile and build the software for the Windows operating system.",
          "dependencies": [],
          "details": "Ensure all dependencies are installed and the build environment is configured correctly for Windows.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Building for macOS",
          "description": "Compile and build the software for the macOS operating system.",
          "dependencies": [],
          "details": "Ensure all dependencies are installed and the build environment is configured correctly for macOS.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Building for Linux",
          "description": "Compile and build the software for the Linux operating system.",
          "dependencies": [],
          "details": "Ensure all dependencies are installed and the build environment is configured correctly for Linux.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Verifying build sizes and functionality",
          "description": "Verify the size and functionality of the builds for all platforms.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Check the build sizes to ensure they are within acceptable limits and test the functionality on each platform.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Set Up Distribution Channels",
      "description": "Prepare distribution via GitHub Releases, Homebrew, and Winget.",
      "details": "Create GitHub Releases for direct downloads. Write Homebrew and Winget manifests for package managers.",
      "testStrategy": "Verify downloads and installations from each distribution channel work as expected.",
      "priority": "medium",
      "dependencies": [
        14
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Creating GitHub Releases",
          "description": "Prepare and publish a new release on GitHub, including version tagging and release notes.",
          "dependencies": [],
          "details": "Ensure the release includes all necessary binaries, changelog, and proper version tagging.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Writing Homebrew manifests",
          "description": "Create or update the Homebrew formula to support the new release.",
          "dependencies": [
            1
          ],
          "details": "The manifest should reference the GitHub release assets and include any required dependencies.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Writing Winget manifests",
          "description": "Create or update the Winget manifest to support the new release.",
          "dependencies": [
            1
          ],
          "details": "The manifest should include metadata, installer URLs, and checksums from the GitHub release.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "Implement Auto-Reload File Watching",
      "description": "Add file watching to automatically reload markdown content when the file changes on disk",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Use notify crate for Rust file watching, emit Tauri events to frontend for reload. Documentation references: IMPLEMENTATION_GUIDES.md section 4 (file watching), TECH_ARCHITECTURE.md (file handling architecture)",
      "testStrategy": "Test file modification detection, watcher cleanup, performance impact",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement file watching with notify crate",
          "description": "Set up file watcher using notify crate to detect changes",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Tauri event emission",
          "description": "Emit events to frontend when file changes are detected",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement watcher cleanup",
          "description": "Ensure watchers are properly stopped when switching files",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Test and validate performance",
          "description": "Verify detection within 1 second and no memory leaks",
          "status": "done"
        }
      ]
    },
    {
      "id": 17,
      "title": "Performance Optimization and Benchmarking",
      "description": "Optimize app performance according to TECH_ARCHITECTURE.md (Performance Architecture section) and IMPLEMENTATION_GUIDES.md section 3. Meet documented benchmarks: cold start <500ms, file open <100ms, memory <50MB, support files up to 10MB with smooth scrolling",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Implementation strategies from docs:\n1. Use lazy loading for non-critical UI components\n2. Implement file chunking for large document processing\n3. Optimize render cycles using memoization\n4. Pre-warm critical services during splash screen\n5. Use compressed binary format for document storage",
      "testStrategy": "1. Benchmark cold start time with system profiler\n2. Measure file open operations with varying file sizes (1KB-10MB)\n3. Monitor memory usage during stress tests\n4. Validate scrolling performance with 10MB files\n5. Compare results against documented benchmarks in TECH_ARCHITECTURE.md",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up benchmarking automation",
          "description": "Create automated performance benchmarking framework to measure cold start time, file open time, memory usage, and file handling performance",
          "dependencies": [],
          "details": "Implement benchmarking scripts using performance measurement tools (e.g., Chrome DevTools, Node.js perf hooks). Store results in a format suitable for comparison (CSV/JSON). Integrate with CI pipeline.",
          "status": "pending",
          "testStrategy": "Verify benchmark scripts produce consistent measurements across multiple runs. Test integration with CI system."
        },
        {
          "id": 2,
          "title": "Profile and optimize cold start performance",
          "description": "Analyze and optimize application cold start time to meet <500ms benchmark",
          "dependencies": [
            1
          ],
          "details": "Use profiling tools to identify bottlenecks. Implement lazy loading for non-critical UI components. Pre-warm critical services during splash screen as per IMPLEMENTATION_GUIDES.md. Optimize initial bundle size.",
          "status": "pending",
          "testStrategy": "Measure cold start time before/after optimizations using benchmarking framework. Verify <500ms target is met."
        },
        {
          "id": 3,
          "title": "Optimize large file handling",
          "description": "Implement optimizations for handling files up to 10MB with smooth scrolling",
          "dependencies": [
            1
          ],
          "details": "Implement file chunking for large document processing. Use compressed binary format for document storage. Optimize render cycles using memoization for file content display.",
          "status": "pending",
          "testStrategy": "Test with 10MB files, measure open time and scrolling performance. Verify <100ms open time and smooth scrolling."
        },
        {
          "id": 4,
          "title": "Implement memory usage monitoring and optimizations",
          "description": "Ensure application memory usage stays below 50MB threshold",
          "dependencies": [
            1
          ],
          "details": "Add memory monitoring instrumentation. Identify and fix memory leaks. Optimize data structures and caching strategies. Implement automatic cleanup of unused resources.",
          "status": "pending",
          "testStrategy": "Run memory usage tests with various file sizes. Verify memory stays <50MB during typical usage patterns."
        },
        {
          "id": 5,
          "title": "Create performance regression testing suite",
          "description": "Establish automated performance regression testing to prevent degradation",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Create test cases covering all performance benchmarks. Set up threshold alerts in CI. Document performance baseline metrics. Implement automated comparison against previous runs.",
          "status": "pending",
          "testStrategy": "Verify regression tests catch intentional performance degradations. Test alerting mechanism."
        }
      ]
    },
    {
      "id": 18,
      "title": "Bundle Size Optimization",
      "description": "Optimize executable size to meet PRD targets: Windows <25MB, macOS <20MB, Linux <30MB",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Documentation Reference: IMPLEMENTATION_GUIDES.md section 5 (build optimization), TECH_ARCHITECTURE.md (bundle optimization)\n\nImplementation Details: Cargo release profile optimization, strip symbols, minimize frontend assets\n\nAcceptance Criteria:\n✅ Windows executable <25MB (excluding runtime dependencies)\n✅ macOS app bundle <20MB\n✅ Linux binary <30MB\n✅ No functionality loss during size optimization",
      "testStrategy": "Build for all platforms, measure sizes, verify functionality remains intact",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Build MVP Version",
      "description": "Create MVP build with core features as defined in TECH_ARCHITECTURE.md and IMPLEMENTATION_GUIDES.md: basic markdown rendering, file associations, drag/drop, and auto-reload",
      "status": "pending",
      "dependencies": [
        2,
        8,
        16
      ],
      "priority": "high",
      "details": "Reference TECH_ARCHITECTURE.md for MVP requirements and IMPLEMENTATION_GUIDES.md for build configuration. Acceptance criteria:\n- MVP executable launches in under 500ms\n- Basic markdown rendering works\n- File associations function properly\n- Drag/drop opens files correctly\n- Auto-reload detects and applies changes\n- Works on all supported platforms",
      "testStrategy": "End-to-end testing of core workflow including:\n- Performance testing (launch time)\n- Markdown rendering verification\n- File association validation\n- Drag/drop functionality check\n- Auto-reload behavior testing\n- Cross-platform compatibility verification",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "CommonMark Compliance Testing",
      "description": "Implement comprehensive testing to ensure full CommonMark specification compliance",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Refer to IMPLEMENTATION_GUIDES.md section 6 for testing requirements. Testing must cover full spec compliance, test suite integration, and performance validation. Include automated CommonMark spec tests and edge case validation.",
      "testStrategy": "1. Implement automated test suite for CommonMark spec compliance\n2. Validate edge cases and corner scenarios\n3. Integrate with existing test infrastructure\n4. Measure and validate parsing performance\n5. Document test coverage and results",
      "subtasks": [
        {
          "id": 1,
          "title": "Review IMPLEMENTATION_GUIDES.md section 6",
          "description": "Understand testing requirements from implementation guide",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Set up automated CommonMark spec test suite",
          "description": "Implement framework for running CommonMark compliance tests",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Design edge case validation tests",
          "description": "Create additional tests for boundary conditions and unusual markdown",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate with CI pipeline",
          "description": "Add compliance tests to continuous integration process",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Document test coverage and results",
          "description": "Create report showing compliance percentage and test results",
          "status": "pending"
        }
      ]
    },
    {
      "id": 21,
      "title": "Code Signing Setup",
      "description": "Set up code signing certificates for Windows and macOS builds to enable trusted distribution according to TECH_ARCHITECTURE.md requirements",
      "status": "pending",
      "dependencies": [
        14
      ],
      "priority": "medium",
      "details": "1. Acquire and configure Windows Authenticode certificate\n2. Acquire and configure macOS Developer ID certificate\n3. Integrate automated signing into CI/CD pipeline\n4. Document signing process and certificate management procedures",
      "testStrategy": "1. Verify signatures on Windows builds using signtool verify\n2. Validate macOS Developer ID signatures using codesign --verify\n3. Test trust chain verification on clean test machines\n4. Verify automated signing works in CI/CD pipeline",
      "subtasks": [
        {
          "id": 1,
          "title": "Review certificate requirements in TECH_ARCHITECTURE.md",
          "description": "Identify all technical requirements for code signing certificates",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Acquire Windows Authenticode certificate",
          "description": "Purchase and configure certificate from trusted CA",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Acquire macOS Developer ID certificate",
          "description": "Obtain certificate from Apple Developer Program",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement automated signing in CI/CD",
          "description": "Integrate signing tools into build pipeline",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Document signing procedures",
          "description": "Create documentation for certificate management and signing process",
          "status": "pending"
        }
      ]
    },
    {
      "id": 22,
      "title": "Fix Documentation-Code Alignment",
      "description": "Documentation has been updated to use vanilla JS patterns consistent with project structure, replacing React examples",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Implementation guides, UI_UX_GUIDE, and architecture docs now align with vanilla HTML/CSS/JavaScript approach. Reference VANILLA_JS_PATTERNS.md for complete implementation examples.",
      "testStrategy": "Verify all documentation examples match vanilla JS patterns in the project. Cross-check with VANILLA_JS_PATTERNS.md for consistency.",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Implement Security Validation",
      "description": "Add file path traversal protection, input sanitization, and external content loading security for markdown files",
      "details": "",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "subtasks": []
    }
  ]
}